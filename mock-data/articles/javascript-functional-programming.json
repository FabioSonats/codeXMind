{
    "id": "8",
    "title": "Programação Funcional em JavaScript",
    "slug": "javascript-functional-programming",
    "excerpt": "Aprenda os conceitos de programação funcional e como aplicá-los em JavaScript moderno",
    "content": "# Programação Funcional em JavaScript\n\nA programação funcional é um paradigma que trata a computação como a avaliação de funções matemáticas, evitando mudanças de estado e dados mutáveis.\n\n## Funções Puras\n\n```javascript\n// Função pura - sempre retorna o mesmo resultado para os mesmos inputs\nfunction somar(a, b) {\n  return a + b;\n}\n\n// Função impura - depende de estado externo\nlet contador = 0;\nfunction incrementar() {\n  contador++;\n  return contador;\n}\n\n// Função pura equivalente\nfunction incrementarPuro(valor) {\n  return valor + 1;\n}\n```\n\n## Imutabilidade\n\n```javascript\n// Mutação (evitar)\nconst array = [1, 2, 3];\narray.push(4); // modifica o array original\n\n// Imutabilidade (preferir)\nconst arrayOriginal = [1, 2, 3];\nconst novoArray = [...arrayOriginal, 4]; // cria novo array\n\n// Com objetos\nconst pessoa = { nome: 'João', idade: 30 };\nconst pessoaAtualizada = { ...pessoa, idade: 31 };\n\n// Deep cloning para objetos aninhados\nconst usuario = {\n  nome: 'Ana',\n  endereco: {\n    cidade: 'São Paulo',\n    estado: 'SP'\n  }\n};\n\nconst usuarioAtualizado = {\n  ...usuario,\n  endereco: {\n    ...usuario.endereco,\n    cidade: 'Rio de Janeiro'\n  }\n};\n```\n\n## Higher-Order Functions\n\n```javascript\n// Função que recebe ou retorna outra função\nfunction criarMultiplicador(fator) {\n  return function(numero) {\n    return numero * fator;\n  };\n}\n\nconst dobrar = criarMultiplicador(2);\nconst triplicar = criarMultiplicador(3);\n\nconsole.log(dobrar(5)); // 10\nconsole.log(triplicar(5)); // 15\n\n// Função que recebe função como parâmetro\nfunction processarArray(array, funcao) {\n  return array.map(funcao);\n}\n\nconst numeros = [1, 2, 3, 4, 5];\nconst quadrados = processarArray(numeros, x => x * x);\nconsole.log(quadrados); // [1, 4, 9, 16, 25]\n```\n\n## Array Methods Funcionais\n\n```javascript\nconst produtos = [\n  { nome: 'Notebook', preco: 2000, categoria: 'eletrônicos' },\n  { nome: 'Mouse', preco: 50, categoria: 'eletrônicos' },\n  { nome: 'Livro', preco: 30, categoria: 'livros' },\n  { nome: 'Teclado', preco: 100, categoria: 'eletrônicos' }\n];\n\n// Map - transformar cada elemento\nconst nomes = produtos.map(produto => produto.nome);\nconst precosComDesconto = produtos.map(produto => ({\n  ...produto,\n  preco: produto.preco * 0.9\n}));\n\n// Filter - filtrar elementos\nconst eletronicos = produtos.filter(produto => produto.categoria === 'eletrônicos');\nconst produtosCaros = produtos.filter(produto => produto.preco > 100);\n\n// Reduce - reduzir array a um valor\nconst total = produtos.reduce((soma, produto) => soma + produto.preco, 0);\nconst produtosPorCategoria = produtos.reduce((acc, produto) => {\n  const categoria = produto.categoria;\n  acc[categoria] = acc[categoria] || [];\n  acc[categoria].push(produto);\n  return acc;\n}, {});\n\n// Find - encontrar primeiro elemento\nconst notebook = produtos.find(produto => produto.nome === 'Notebook');\n\n// Some e Every - verificar condições\nconst temProdutoCaro = produtos.some(produto => produto.preco > 1000);\nconst todosTemPreco = produtos.every(produto => produto.preco > 0);\n```\n\n## Currying\n\n```javascript\n// Currying - transformar função com múltiplos parâmetros em sequência de funções\nfunction somar(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\n// Arrow functions\nconst somarCurried = a => b => c => a + b + c;\n\n// Uso\nconst resultado = somarCurried(1)(2)(3); // 6\n\n// Aplicação prática\nfunction criarFiltro(campo) {\n  return function(valor) {\n    return function(objetos) {\n      return objetos.filter(obj => obj[campo] === valor);\n    };\n  };\n}\n\nconst filtrarPorCategoria = criarFiltro('categoria');\nconst filtrarEletronicos = filtrarPorCategoria('eletrônicos');\nconst eletronicosFiltrados = filtrarEletronicos(produtos);\n```\n\n## Composition\n\n```javascript\n// Composition - combinar funções simples em funções complexas\nconst pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);\n\nconst compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);\n\n// Funções simples\nconst adicionarUm = x => x + 1;\nconst multiplicarPorDois = x => x * 2;\nconst aoQuadrado = x => x * x;\n\n// Composition\nconst transformar = pipe(\n  adicionarUm,\n  multiplicarPorDois,\n  aoQuadrado\n);\n\nconsole.log(transformar(3)); // ((3 + 1) * 2)² = 64\n\n// Aplicação prática com dados\nconst processarProdutos = pipe(\n  produtos => produtos.filter(p => p.preco > 50),\n  produtos => produtos.map(p => ({ ...p, preco: p.preco * 1.1 })),\n  produtos => produtos.sort((a, b) => b.preco - a.preco)\n);\n\nconst produtosProcessados = processarProdutos(produtos);\n```\n\n## Functors e Monads\n\n```javascript\n// Maybe Monad - lidar com valores que podem ser null/undefined\nclass Maybe {\n  constructor(value) {\n    this.value = value;\n  }\n\n  static of(value) {\n    return new Maybe(value);\n  }\n\n  map(fn) {\n    return this.value == null ? Maybe.of(null) : Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return this.value == null ? Maybe.of(null) : fn(this.value);\n  }\n\n  getOrElse(defaultValue) {\n    return this.value == null ? defaultValue : this.value;\n  }\n}\n\n// Uso do Maybe\nconst usuario = { nome: 'João', endereco: { cidade: 'São Paulo' } };\n\nconst cidade = Maybe.of(usuario)\n  .map(u => u.endereco)\n  .map(e => e.cidade)\n  .getOrElse('Cidade não encontrada');\n\nconsole.log(cidade); // São Paulo\n\n// Either Monad - lidar com sucesso ou erro\nclass Either {\n  constructor(value, isLeft = false) {\n    this.value = value;\n    this.isLeft = isLeft;\n  }\n\n  static left(value) {\n    return new Either(value, true);\n  }\n\n  static right(value) {\n    return new Either(value, false);\n  }\n\n  map(fn) {\n    return this.isLeft ? this : Either.right(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return this.isLeft ? this : fn(this.value);\n  }\n\n  getOrElse(defaultValue) {\n    return this.isLeft ? defaultValue : this.value;\n  }\n}\n\n// Uso do Either\nfunction dividir(a, b) {\n  return b === 0 ? Either.left('Divisão por zero') : Either.right(a / b);\n}\n\nconst resultado = dividir(10, 2)\n  .map(x => x * 2)\n  .getOrElse('Erro na operação');\n\nconsole.log(resultado); // 10\n```\n\n## Recursão\n\n```javascript\n// Recursão simples\nfunction fatorial(n) {\n  if (n <= 1) return 1;\n  return n * fatorial(n - 1);\n}\n\n// Recursão com tail call optimization\nfunction fatorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return fatorialTail(n - 1, n * acc);\n}\n\n// Recursão em estruturas de dados\nfunction somarArray(array) {\n  if (array.length === 0) return 0;\n  return array[0] + somarArray(array.slice(1));\n}\n\n// Recursão para árvores\nfunction buscarEmArvore(arvore, valor) {\n  if (arvore.valor === valor) return arvore;\n  \n  for (const filho of arvore.filhos || []) {\n    const resultado = buscarEmArvore(filho, valor);\n    if (resultado) return resultado;\n  }\n  \n  return null;\n}\n```\n\n## Conclusão\n\nA programação funcional em JavaScript oferece:\n\n- **Código mais previsível** com funções puras\n- **Menos bugs** com imutabilidade\n- **Melhor testabilidade** com funções isoladas\n- **Código mais expressivo** com composition\n- **Tratamento elegante de erros** com monads\n\nComece aplicando esses conceitos gradualmente em seus projetos!",
    "author": {
        "id": "1",
        "name": "Fábio Ferreira",
        "avatar": "/avatars/fabio.jpg",
        "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
        "social": {
            "github": "https://github.com/FabioSonats",
            "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
            "portfolio": "https://fabiosonats.github.io/my-portifolio/"
        }
    },
    "publishedAt": "2025-01-26T16:00:00Z",
    "updatedAt": "2025-01-26T16:00:00Z",
    "tags": [
        "JavaScript",
        "Programação Funcional",
        "FP",
        "Imutabilidade"
    ],
    "category": "javascript",
    "language": "pt",
    "readingTime": 16,
    "featured": true
}
