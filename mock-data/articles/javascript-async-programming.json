{
    "id": "7",
    "title": "Programação Assíncrona em JavaScript",
    "slug": "javascript-async-programming",
    "excerpt": "Domine callbacks, Promises, async/await e outras técnicas de programação assíncrona em JavaScript",
    "content": "# Programação Assíncrona em JavaScript\n\nA programação assíncrona é fundamental em JavaScript, especialmente para operações que podem demorar, como requisições de rede, leitura de arquivos ou operações de banco de dados.\n\n## Callbacks\n\n```javascript\n// Callback simples\nfunction buscarUsuario(id, callback) {\n  setTimeout(() => {\n    const usuario = { id, nome: 'João', email: 'joao@email.com' };\n    callback(null, usuario);\n  }, 1000);\n}\n\n// Uso do callback\nbuscarUsuario(1, (erro, usuario) => {\n  if (erro) {\n    console.error('Erro:', erro);\n  } else {\n    console.log('Usuário:', usuario);\n  }\n});\n\n// Callback Hell (problema)\nbuscarUsuario(1, (erro, usuario) => {\n  if (erro) return console.error(erro);\n  \n  buscarPosts(usuario.id, (erro, posts) => {\n    if (erro) return console.error(erro);\n    \n    buscarComentarios(posts[0].id, (erro, comentarios) => {\n      if (erro) return console.error(erro);\n      \n      console.log('Comentários:', comentarios);\n    });\n  });\n});\n```\n\n## Promises\n\n```javascript\n// Criando uma Promise\nfunction buscarUsuarioPromise(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id > 0) {\n        const usuario = { id, nome: 'João', email: 'joao@email.com' };\n        resolve(usuario);\n      } else {\n        reject(new Error('ID inválido'));\n      }\n    }, 1000);\n  });\n}\n\n// Usando Promises\nbuscarUsuarioPromise(1)\n  .then(usuario => {\n    console.log('Usuário:', usuario);\n    return buscarPostsPromise(usuario.id);\n  })\n  .then(posts => {\n    console.log('Posts:', posts);\n    return buscarComentariosPromise(posts[0].id);\n  })\n  .then(comentarios => {\n    console.log('Comentários:', comentarios);\n  })\n  .catch(erro => {\n    console.error('Erro:', erro);\n  });\n\n// Promise.all - executar múltiplas promises em paralelo\nPromise.all([\n  buscarUsuarioPromise(1),\n  buscarUsuarioPromise(2),\n  buscarUsuarioPromise(3)\n])\n.then(usuarios => {\n  console.log('Todos os usuários:', usuarios);\n})\n.catch(erro => {\n  console.error('Erro ao buscar usuários:', erro);\n});\n\n// Promise.allSettled - aguarda todas, mesmo com falhas\nPromise.allSettled([\n  buscarUsuarioPromise(1),\n  buscarUsuarioPromise(-1), // vai falhar\n  buscarUsuarioPromise(3)\n])\n.then(resultados => {\n  resultados.forEach((resultado, index) => {\n    if (resultado.status === 'fulfilled') {\n      console.log(`Usuário ${index + 1}:`, resultado.value);\n    } else {\n      console.log(`Erro no usuário ${index + 1}:`, resultado.reason);\n    }\n  });\n});\n\n// Promise.race - primeira promise a resolver\nPromise.race([\n  buscarUsuarioPromise(1),\n  buscarUsuarioPromise(2),\n  buscarUsuarioPromise(3)\n])\n.then(primeiroUsuario => {\n  console.log('Primeiro usuário encontrado:', primeiroUsuario);\n});\n```\n\n## Async/Await\n\n```javascript\n// Função async\nasync function buscarDadosCompletos(id) {\n  try {\n    const usuario = await buscarUsuarioPromise(id);\n    console.log('Usuário encontrado:', usuario);\n    \n    const posts = await buscarPostsPromise(usuario.id);\n    console.log('Posts do usuário:', posts);\n    \n    const comentarios = await buscarComentariosPromise(posts[0].id);\n    console.log('Comentários:', comentarios);\n    \n    return { usuario, posts, comentarios };\n  } catch (erro) {\n    console.error('Erro ao buscar dados:', erro);\n    throw erro;\n  }\n}\n\n// Usando a função async\nbuscarDadosCompletos(1)\n  .then(dados => {\n    console.log('Dados completos:', dados);\n  })\n  .catch(erro => {\n    console.error('Erro:', erro);\n  });\n\n// Async/await com Promise.all\nasync function buscarTodosUsuarios() {\n  try {\n    const usuarios = await Promise.all([\n      buscarUsuarioPromise(1),\n      buscarUsuarioPromise(2),\n      buscarUsuarioPromise(3)\n    ]);\n    \n    console.log('Todos os usuários:', usuarios);\n    return usuarios;\n  } catch (erro) {\n    console.error('Erro ao buscar usuários:', erro);\n    throw erro;\n  }\n}\n```\n\n## Fetch API\n\n```javascript\n// Requisição GET simples\nasync function buscarDados() {\n  try {\n    const response = await fetch('https://api.exemplo.com/usuarios');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const dados = await response.json();\n    return dados;\n  } catch (erro) {\n    console.error('Erro na requisição:', erro);\n    throw erro;\n  }\n}\n\n// Requisição POST com dados\nasync function criarUsuario(dadosUsuario) {\n  try {\n    const response = await fetch('https://api.exemplo.com/usuarios', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token123'\n      },\n      body: JSON.stringify(dadosUsuario)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const novoUsuario = await response.json();\n    return novoUsuario;\n  } catch (erro) {\n    console.error('Erro ao criar usuário:', erro);\n    throw erro;\n  }\n}\n\n// Upload de arquivo\nasync function uploadArquivo(arquivo) {\n  const formData = new FormData();\n  formData.append('arquivo', arquivo);\n  \n  try {\n    const response = await fetch('https://api.exemplo.com/upload', {\n      method: 'POST',\n      body: formData\n    });\n    \n    const resultado = await response.json();\n    return resultado;\n  } catch (erro) {\n    console.error('Erro no upload:', erro);\n    throw erro;\n  }\n}\n```\n\n## Generators\n\n```javascript\n// Generator simples\nfunction* contador() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n\nconst gen = contador();\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n\n// Generator para sequência de Fibonacci\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nfor (let i = 0; i < 10; i++) {\n  console.log(fib.next().value); // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n}\n\n// Generator async\nasync function* buscarDadosAsync() {\n  const urls = [\n    'https://api.exemplo.com/usuarios',\n    'https://api.exemplo.com/posts',\n    'https://api.exemplo.com/comentarios'\n  ];\n  \n  for (const url of urls) {\n    const response = await fetch(url);\n    const dados = await response.json();\n    yield dados;\n  }\n}\n\n// Usando o generator async\n(async () => {\n  for await (const dados of buscarDadosAsync()) {\n    console.log('Dados recebidos:', dados);\n  }\n})();\n```\n\n## Web Workers\n\n```javascript\n// main.js\nconst worker = new Worker('worker.js');\n\n// Enviar dados para o worker\nworker.postMessage({ tipo: 'calcular', dados: [1, 2, 3, 4, 5] });\n\n// Receber resultado do worker\nworker.onmessage = function(event) {\n  console.log('Resultado:', event.data);\n};\n\n// Tratar erros do worker\nworker.onerror = function(erro) {\n  console.error('Erro no worker:', erro);\n};\n\n// worker.js\nself.onmessage = function(event) {\n  const { tipo, dados } = event.data;\n  \n  if (tipo === 'calcular') {\n    // Processamento pesado\n    const resultado = dados.reduce((acc, num) => acc + num * num, 0);\n    \n    // Enviar resultado de volta\n    self.postMessage({ resultado });\n  }\n};\n```\n\n## AbortController\n\n```javascript\n// Cancelar requisição\nasync function buscarDadosComCancelamento() {\n  const controller = new AbortController();\n  \n  // Cancelar após 5 segundos\n  const timeoutId = setTimeout(() => {\n    controller.abort();\n  }, 5000);\n  \n  try {\n    const response = await fetch('https://api.exemplo.com/dados', {\n      signal: controller.signal\n    });\n    \n    clearTimeout(timeoutId);\n    const dados = await response.json();\n    return dados;\n  } catch (erro) {\n    if (erro.name === 'AbortError') {\n      console.log('Requisição cancelada');\n    } else {\n      console.error('Erro na requisição:', erro);\n    }\n    throw erro;\n  }\n}\n```\n\n## Conclusão\n\nA programação assíncrona em JavaScript evoluiu muito, desde callbacks até async/await. Cada técnica tem seu lugar:\n\n- **Callbacks**: Simples, mas podem levar ao \"callback hell\"\n- **Promises**: Melhor controle de fluxo, mas ainda podem ser verbosas\n- **Async/Await**: Sintaxe mais limpa e legível\n- **Generators**: Úteis para sequências e iteração customizada\n- **Web Workers**: Para processamento pesado sem bloquear a UI\n\nEscolha a técnica mais adequada para cada situação!",
    "author": {
        "id": "1",
        "name": "Fábio Ferreira",
        "avatar": "/avatars/fabio.jpg",
        "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
        "social": {
            "github": "https://github.com/FabioSonats",
            "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
            "portfolio": "https://fabiosonats.github.io/my-portifolio/"
        }
    },
    "publishedAt": "2025-01-26T14:30:00Z",
    "updatedAt": "2025-01-26T14:30:00Z",
    "tags": [
        "JavaScript",
        "Async",
        "Promises",
        "Async/Await"
    ],
    "category": "javascript",
    "language": "pt",
    "readingTime": 18,
    "featured": true
}
