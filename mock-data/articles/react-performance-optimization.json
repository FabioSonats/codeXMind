{
    "id": "10",
    "title": "Otimização de Performance em React",
    "slug": "react-performance-optimization",
    "excerpt": "Técnicas avançadas para otimizar a performance de aplicações React",
    "content": "# Otimização de Performance em React\n\nA performance é crucial para uma boa experiência do usuário. Vamos explorar técnicas para otimizar aplicações React.\n\n## React.memo\n\n```jsx\n// Componente que re-renderiza desnecessariamente\nfunction UsuarioCard({ usuario, onEdit }) {\n  console.log('UsuarioCard renderizado');\n  \n  return (\n    <div>\n      <h3>{usuario.nome}</h3>\n      <p>{usuario.email}</p>\n      <button onClick={() => onEdit(usuario.id)}>Editar</button>\n    </div>\n  );\n}\n\n// Otimizado com React.memo\nconst UsuarioCard = React.memo(function UsuarioCard({ usuario, onEdit }) {\n  console.log('UsuarioCard renderizado');\n  \n  return (\n    <div>\n      <h3>{usuario.nome}</h3>\n      <p>{usuario.email}</p>\n      <button onClick={() => onEdit(usuario.id)}>Editar</button>\n    </div>\n  );\n});\n\n// Comparação customizada\nconst UsuarioCard = React.memo(function UsuarioCard({ usuario, onEdit }) {\n  return (\n    <div>\n      <h3>{usuario.nome}</h3>\n      <p>{usuario.email}</p>\n      <button onClick={() => onEdit(usuario.id)}>Editar</button>\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Retorna true se as props são iguais (não re-renderizar)\n  return (\n    prevProps.usuario.nome === nextProps.usuario.nome &&\n    prevProps.usuario.email === nextProps.usuario.email &&\n    prevProps.onEdit === nextProps.onEdit\n  );\n});\n```\n\n## useMemo\n\n```jsx\nfunction ListaUsuarios({ usuarios, filtro }) {\n  // Cálculo pesado que só deve executar quando usuarios ou filtro mudarem\n  const usuariosFiltrados = useMemo(() => {\n    console.log('Filtrando usuários...');\n    \n    return usuarios.filter(usuario => \n      usuario.nome.toLowerCase().includes(filtro.toLowerCase())\n    );\n  }, [usuarios, filtro]);\n\n  // Objeto complexo que só deve ser recriado quando necessário\n  const configuracao = useMemo(() => ({\n    tema: 'dark',\n    idioma: 'pt-BR',\n    formatacao: {\n      data: 'DD/MM/YYYY',\n      moeda: 'BRL'\n    }\n  }), []); // Array vazio = nunca recriar\n\n  return (\n    <div>\n      {usuariosFiltrados.map(usuario => (\n        <UsuarioCard key={usuario.id} usuario={usuario} />\n      ))}\n    </div>\n  );\n}\n```\n\n## useCallback\n\n```jsx\nfunction ListaUsuarios({ usuarios }) {\n  const [contador, setContador] = useState(0);\n\n  // Função que é recriada a cada render\n  const handleEdit = (id) => {\n    console.log('Editando usuário:', id);\n  };\n\n  // Função otimizada com useCallback\n  const handleEditCallback = useCallback((id) => {\n    console.log('Editando usuário:', id);\n  }, []); // Array vazio = função nunca muda\n\n  // Função que depende de estado\n  const handleDelete = useCallback((id) => {\n    console.log('Deletando usuário:', id, 'Contador:', contador);\n  }, [contador]); // Recriar quando contador mudar\n\n  return (\n    <div>\n      <button onClick={() => setContador(c => c + 1)}>\n        Contador: {contador}\n      </button>\n      \n      {usuarios.map(usuario => (\n        <UsuarioCard \n          key={usuario.id} \n          usuario={usuario} \n          onEdit={handleEditCallback}\n          onDelete={handleDelete}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n## Lazy Loading e Code Splitting\n\n```jsx\n// Lazy loading de componentes\nimport { lazy, Suspense } from 'react';\n\n// Componente carregado sob demanda\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Relatorios = lazy(() => import('./Relatorios'));\nconst Configuracoes = lazy(() => import('./Configuracoes'));\n\nfunction App() {\n  const [paginaAtual, setPaginaAtual] = useState('dashboard');\n\n  const renderizarPagina = () => {\n    switch (paginaAtual) {\n      case 'dashboard':\n        return <Dashboard />;\n      case 'relatorios':\n        return <Relatorios />;\n      case 'configuracoes':\n        return <Configuracoes />;\n      default:\n        return <Dashboard />;\n    }\n  };\n\n  return (\n    <div>\n      <nav>\n        <button onClick={() => setPaginaAtual('dashboard')}>Dashboard</button>\n        <button onClick={() => setPaginaAtual('relatorios')}>Relatórios</button>\n        <button onClick={() => setPaginaAtual('configuracoes')}>Configurações</button>\n      </nav>\n      \n      <Suspense fallback={<div>Carregando...</div>}>\n        {renderizarPagina()}\n      </Suspense>\n    </div>\n  );\n}\n\n// Lazy loading com React Router\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst Sobre = lazy(() => import('./pages/Sobre'));\nconst Contato = lazy(() => import('./pages/Contato'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<div>Carregando página...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/sobre\" element={<Sobre />} />\n          <Route path=\"/contato\" element={<Contato />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n## Virtualização\n\n```jsx\n// Para listas grandes, use virtualização\nimport { FixedSizeList as List } from 'react-window';\n\nfunction ListaGrande({ itens }) {\n  const ItemRenderer = ({ index, style }) => (\n    <div style={style}>\n      <div>\n        <strong>{itens[index].nome}</strong>\n        <p>{itens[index].descricao}</p>\n      </div>\n    </div>\n  );\n\n  return (\n    <List\n      height={600} // Altura do container\n      itemCount={itens.length} // Número total de itens\n      itemSize={80} // Altura de cada item\n      width=\"100%\"\n    >\n      {ItemRenderer}\n    </List>\n  );\n}\n\n// Lista com altura variável\nimport { VariableSizeList as List } from 'react-window';\n\nfunction ListaAlturaVariavel({ itens }) {\n  const getItemSize = (index) => {\n    // Calcular altura baseada no conteúdo\n    const item = itens[index];\n    return item.descricao.length > 100 ? 120 : 80;\n  };\n\n  const ItemRenderer = ({ index, style }) => (\n    <div style={style}>\n      <div>\n        <strong>{itens[index].nome}</strong>\n        <p>{itens[index].descricao}</p>\n      </div>\n    </div>\n  );\n\n  return (\n    <List\n      height={600}\n      itemCount={itens.length}\n      itemSize={getItemSize}\n      width=\"100%\"\n    >\n      {ItemRenderer}\n    </List>\n  );\n}\n```\n\n## Debounce e Throttle\n\n```jsx\n// Hook para debounce\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Hook para throttle\nfunction useThrottle(value, delay) {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const lastExecuted = useRef(Date.now());\n\n  useEffect(() => {\n    if (Date.now() >= lastExecuted.current + delay) {\n      lastExecuted.current = Date.now();\n      setThrottledValue(value);\n    } else {\n      const timer = setTimeout(() => {\n        lastExecuted.current = Date.now();\n        setThrottledValue(value);\n      }, delay);\n\n      return () => clearTimeout(timer);\n    }\n  }, [value, delay]);\n\n  return throttledValue;\n}\n\n// Uso em busca\nfunction BuscaUsuarios() {\n  const [termo, setTermo] = useState('');\n  const [resultados, setResultados] = useState([]);\n  \n  // Debounce do termo de busca\n  const termoDebounced = useDebounce(termo, 300);\n\n  useEffect(() => {\n    if (termoDebounced) {\n      buscarUsuarios(termoDebounced).then(setResultados);\n    } else {\n      setResultados([]);\n    }\n  }, [termoDebounced]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={termo}\n        onChange={(e) => setTermo(e.target.value)}\n        placeholder=\"Buscar usuários...\"\n      />\n      \n      {resultados.map(usuario => (\n        <div key={usuario.id}>{usuario.nome}</div>\n      ))}\n    </div>\n  );\n}\n```\n\n## Otimização de Imagens\n\n```jsx\n// Componente de imagem otimizada\nfunction ImagemOtimizada({ src, alt, ...props }) {\n  const [carregando, setCarregando] = useState(true);\n  const [erro, setErro] = useState(false);\n\n  const handleLoad = () => {\n    setCarregando(false);\n  };\n\n  const handleError = () => {\n    setCarregando(false);\n    setErro(true);\n  };\n\n  return (\n    <div style={{ position: 'relative' }}>\n      {carregando && (\n        <div style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0,\n          backgroundColor: '#f0f0f0',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center'\n        }}>\n          Carregando...\n        </div>\n      )}\n      \n      {erro ? (\n        <div style={{\n          backgroundColor: '#f0f0f0',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          minHeight: '200px'\n        }}>\n          Erro ao carregar imagem\n        </div>\n      ) : (\n        <img\n          src={src}\n          alt={alt}\n          onLoad={handleLoad}\n          onError={handleError}\n          style={{\n            opacity: carregando ? 0 : 1,\n            transition: 'opacity 0.3s'\n          }}\n          {...props}\n        />\n      )}\n    </div>\n  );\n}\n\n// Lazy loading de imagens\nfunction ImagemLazy({ src, alt, ...props }) {\n  const [inView, setInView] = useState(false);\n  const imgRef = useRef();\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setInView(true);\n          observer.disconnect();\n        }\n      },\n      { threshold: 0.1 }\n    );\n\n    if (imgRef.current) {\n      observer.observe(imgRef.current);\n    }\n\n    return () => observer.disconnect();\n  }, []);\n\n  return (\n    <div ref={imgRef} style={{ minHeight: '200px' }}>\n      {inView ? (\n        <ImagemOtimizada src={src} alt={alt} {...props} />\n      ) : (\n        <div style={{\n          backgroundColor: '#f0f0f0',\n          height: '200px',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center'\n        }}>\n          Carregando...\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Bundle Analysis\n\n```bash\n# Instalar o analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n# Adicionar script no package.json\n\"scripts\": {\n  \"analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\"\n}\n\n# Executar análise\nnpm run analyze\n```\n\n## Profiling com React DevTools\n\n```jsx\n// Habilitar profiling em desenvolvimento\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration, baseDuration, startTime, commitTime) {\n  console.log('Profiler:', {\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime\n  });\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <div>\n        <Header />\n        <Main />\n      </div>\n    </Profiler>\n  );\n}\n```\n\n## Conclusão\n\nPara otimizar performance em React:\n\n1. **Use React.memo** para componentes que re-renderizam desnecessariamente\n2. **Use useMemo** para cálculos pesados\n3. **Use useCallback** para funções passadas como props\n4. **Implemente lazy loading** para code splitting\n5. **Use virtualização** para listas grandes\n6. **Implemente debounce/throttle** para eventos frequentes\n7. **Otimize imagens** com lazy loading\n8. **Analise o bundle** regularmente\n9. **Use React DevTools Profiler** para identificar gargalos\n\nLembre-se: otimize apenas quando necessário e meça o impacto das otimizações!",
    "author": {
        "id": "1",
        "name": "Fábio Ferreira",
        "avatar": "/avatars/fabio.jpg",
        "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
        "social": {
            "github": "https://github.com/FabioSonats",
            "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
            "portfolio": "https://fabiosonats.github.io/my-portifolio/"
        }
    },
    "publishedAt": "2025-01-26T20:00:00Z",
    "updatedAt": "2025-01-26T20:00:00Z",
    "tags": [
        "React",
        "Performance",
        "Otimização",
        "Memo"
    ],
    "category": "react",
    "language": "pt",
    "readingTime": 20,
    "featured": true
}
