{
    "id": "5",
    "title": "Programação Orientada a Objetos com JavaScript",
    "slug": "programacao-orientada-objetos-javascript",
    "excerpt": "Aprenda os conceitos fundamentais de Programação Orientada a Objetos usando JavaScript moderno",
    "content": "# Programação Orientada a Objetos com JavaScript\n\nA Programação Orientada a Objetos (OOP) é um paradigma de programação que organiza o código em objetos que contêm dados (propriedades) e comportamentos (métodos). JavaScript, apesar de ser uma linguagem multi-paradigma, oferece excelente suporte para OOP.\n\n## O que é Programação Orientada a Objetos?\n\nOOP é um paradigma baseado no conceito de \"objetos\", que podem conter dados na forma de campos (atributos) e código na forma de procedimentos (métodos). Os quatro pilares fundamentais da OOP são:\n\n- **Encapsulamento**: Ocultar detalhes internos e expor apenas o necessário\n- **Herança**: Criar novas classes baseadas em classes existentes\n- **Polimorfismo**: Usar uma interface única para diferentes tipos\n- **Abstração**: Simplificar a complexidade através de modelos\n\n## Classes em JavaScript\n\n### Sintaxe Básica de Classes\n\n```javascript\n// Definição de uma classe\nclass Pessoa {\n  constructor(nome, idade) {\n    this.nome = nome;\n    this.idade = idade;\n  }\n\n  // Método de instância\n  apresentar() {\n    return `Olá, eu sou ${this.nome} e tenho ${this.idade} anos`;\n  }\n\n  // Método estático\n  static compararIdades(pessoa1, pessoa2) {\n    return pessoa1.idade - pessoa2.idade;\n  }\n}\n\n// Criando uma instância\nconst joao = new Pessoa('João', 25);\nconsole.log(joao.apresentar()); // \"Olá, eu sou João e tenho 25 anos\"\n\n// Usando método estático\nconst maria = new Pessoa('Maria', 30);\nconsole.log(Pessoa.compararIdades(joao, maria)); // -5\n```\n\n### Propriedades e Métodos\n\n```javascript\nclass ContaBancaria {\n  constructor(titular, saldoInicial = 0) {\n    this.titular = titular;\n    this._saldo = saldoInicial; // Propriedade privada (convenção)\n    this.transacoes = [];\n  }\n\n  // Getter\n  get saldo() {\n    return this._saldo;\n  }\n\n  // Setter\n  set saldo(novoSaldo) {\n    if (novoSaldo < 0) {\n      throw new Error('Saldo não pode ser negativo');\n    }\n    this._saldo = novoSaldo;\n  }\n\n  // Método público\n  depositar(valor) {\n    if (valor <= 0) {\n      throw new Error('Valor deve ser positivo');\n    }\n    this._saldo += valor;\n    this.transacoes.push({\n      tipo: 'depósito',\n      valor: valor,\n      data: new Date()\n    });\n    return this._saldo;\n  }\n\n  // Método privado (convenção)\n  _validarSaque(valor) {\n    return valor > 0 && valor <= this._saldo;\n  }\n\n  sacar(valor) {\n    if (!this._validarSaque(valor)) {\n      throw new Error('Valor inválido ou saldo insuficiente');\n    }\n    this._saldo -= valor;\n    this.transacoes.push({\n      tipo: 'saque',\n      valor: valor,\n      data: new Date()\n    });\n    return this._saldo;\n  }\n\n  // Método para obter extrato\n  obterExtrato() {\n    return {\n      titular: this.titular,\n      saldo: this._saldo,\n      transacoes: this.transacoes\n    };\n  }\n}\n\n// Uso da classe\nconst conta = new ContaBancaria('Ana Silva', 1000);\nconta.depositar(500);\nconta.sacar(200);\nconsole.log(conta.saldo); // 1300\nconsole.log(conta.obterExtrato());\n```\n\n## Herança\n\n### Herança Simples\n\n```javascript\n// Classe pai\nclass Animal {\n  constructor(nome, especie) {\n    this.nome = nome;\n    this.especie = especie;\n  }\n\n  fazerSom() {\n    return 'O animal faz um som';\n  }\n\n  apresentar() {\n    return `Sou um ${this.especie} chamado ${this.nome}`;\n  }\n}\n\n// Classe filha\nclass Cachorro extends Animal {\n  constructor(nome, raca) {\n    super(nome, 'Canino'); // Chama o construtor da classe pai\n    this.raca = raca;\n  }\n\n  // Sobrescreve o método da classe pai\n  fazerSom() {\n    return 'Au au!';\n  }\n\n  // Método específico da classe filha\n  latir() {\n    return `${this.nome} está latindo: ${this.fazerSom()}`;\n  }\n\n  // Método que chama o método da classe pai\n  apresentarCompleto() {\n    return `${super.apresentar()} da raça ${this.raca}`;\n  }\n}\n\n// Uso da herança\nconst rex = new Cachorro('Rex', 'Pastor Alemão');\nconsole.log(rex.apresentar()); // \"Sou um Canino chamado Rex\"\nconsole.log(rex.fazerSom()); // \"Au au!\"\nconsole.log(rex.latir()); // \"Rex está latindo: Au au!\"\nconsole.log(rex.apresentarCompleto()); // \"Sou um Canino chamado Rex da raça Pastor Alemão\"\n```\n\n### Herança Múltipla com Mixins\n\n```javascript\n// Mixin para funcionalidade de voo\nconst Voar = {\n  voar() {\n    return `${this.nome} está voando`;\n  },\n  pousar() {\n    return `${this.nome} pousou`;\n  }\n};\n\n// Mixin para funcionalidade aquática\nconst Nadar = {\n  nadar() {\n    return `${this.nome} está nadando`;\n  },\n  mergulhar() {\n    return `${this.nome} mergulhou`;\n  }\n};\n\n// Classe que usa mixins\nclass Pato extends Animal {\n  constructor(nome) {\n    super(nome, 'Ave');\n  }\n\n  fazerSom() {\n    return 'Quack quack!';\n  }\n}\n\n// Aplicando mixins\nObject.assign(Pato.prototype, Voar, Nadar);\n\nconst pato = new Pato('Donald');\nconsole.log(pato.fazerSom()); // \"Quack quack!\"\nconsole.log(pato.voar()); // \"Donald está voando\"\nconsole.log(pato.nadar()); // \"Donald está nadando\"\n```\n\n## Encapsulamento\n\n### Campos Privados (ES2022)\n\n```javascript\nclass ContaCorrente {\n  // Campos privados (usando #)\n  #saldo = 0;\n  #senha;\n\n  constructor(titular, senha) {\n    this.titular = titular;\n    this.#senha = senha;\n  }\n\n  // Método privado\n  #validarSenha(senha) {\n    return senha === this.#senha;\n  }\n\n  // Método público que usa método privado\n  verificarSaldo(senha) {\n    if (!this.#validarSenha(senha)) {\n      throw new Error('Senha incorreta');\n    }\n    return this.#saldo;\n  }\n\n  depositar(valor, senha) {\n    if (!this.#validarSenha(senha)) {\n      throw new Error('Senha incorreta');\n    }\n    this.#saldo += valor;\n    return this.#saldo;\n  }\n\n  sacar(valor, senha) {\n    if (!this.#validarSenha(senha)) {\n      throw new Error('Senha incorreta');\n    }\n    if (valor > this.#saldo) {\n      throw new Error('Saldo insuficiente');\n    }\n    this.#saldo -= valor;\n    return this.#saldo;\n  }\n}\n\n// Uso da classe com encapsulamento\nconst conta = new ContaCorrente('João', '1234');\nconta.depositar(1000, '1234');\nconsole.log(conta.verificarSaldo('1234')); // 1000\n// console.log(conta.#saldo); // Erro! Campo privado não acessível\n```\n\n### Encapsulamento com Closures\n\n```javascript\nfunction criarContador() {\n  let contador = 0; // Variável privada\n\n  return {\n    incrementar() {\n      contador++;\n      return contador;\n    },\n    decrementar() {\n      contador--;\n      return contador;\n    },\n    obterValor() {\n      return contador;\n    },\n    resetar() {\n      contador = 0;\n      return contador;\n    }\n  };\n}\n\n// Uso do contador encapsulado\nconst contador = criarContador();\nconsole.log(contador.incrementar()); // 1\nconsole.log(contador.incrementar()); // 2\nconsole.log(contador.obterValor()); // 2\nconsole.log(contador.decrementar()); // 1\n// console.log(contador.contador); // undefined - variável privada\n```\n\n## Polimorfismo\n\n### Polimorfismo por Herança\n\n```javascript\n// Classe base abstrata\nclass Forma {\n  constructor(nome) {\n    this.nome = nome;\n  }\n\n  // Método que será sobrescrito pelas classes filhas\n  calcularArea() {\n    throw new Error('Método calcularArea deve ser implementado');\n  }\n\n  // Método que usa polimorfismo\n  obterInformacoes() {\n    return `${this.nome}: Área = ${this.calcularArea()}`;\n  }\n}\n\n// Classes filhas que implementam o mesmo método de forma diferente\nclass Retangulo extends Forma {\n  constructor(largura, altura) {\n    super('Retângulo');\n    this.largura = largura;\n    this.altura = altura;\n  }\n\n  calcularArea() {\n    return this.largura * this.altura;\n  }\n}\n\nclass Circulo extends Forma {\n  constructor(raio) {\n    super('Círculo');\n    this.raio = raio;\n  }\n\n  calcularArea() {\n    return Math.PI * this.raio * this.raio;\n  }\n}\n\nclass Triangulo extends Forma {\n  constructor(base, altura) {\n    super('Triângulo');\n    this.base = base;\n    this.altura = altura;\n  }\n\n  calcularArea() {\n    return (this.base * this.altura) / 2;\n  }\n}\n\n// Uso do polimorfismo\nconst formas = [\n  new Retangulo(5, 3),\n  new Circulo(4),\n  new Triangulo(6, 8)\n];\n\n// O mesmo método é chamado, mas cada classe executa sua própria implementação\nformas.forEach(forma => {\n  console.log(forma.obterInformacoes());\n});\n// Retângulo: Área = 15\n// Círculo: Área = 50.26548245743669\n// Triângulo: Área = 24\n```\n\n### Polimorfismo com Interfaces\n\n```javascript\n// Simulando interfaces com classes abstratas\nclass Animal {\n  constructor(nome) {\n    this.nome = nome;\n  }\n\n  // Métodos que devem ser implementados pelas classes filhas\n  mover() {\n    throw new Error('Método mover deve ser implementado');\n  }\n\n  fazerSom() {\n    throw new Error('Método fazerSom deve ser implementado');\n  }\n}\n\n// Classes que implementam a \"interface\" Animal\nclass Peixe extends Animal {\n  constructor(nome) {\n    super(nome);\n  }\n\n  mover() {\n    return `${this.nome} está nadando`;\n  }\n\n  fazerSom() {\n    return `${this.nome} faz bolhas`;\n  }\n}\n\nclass Passaro extends Animal {\n  constructor(nome) {\n    super(nome);\n  }\n\n  mover() {\n    return `${this.nome} está voando`;\n  }\n\n  fazerSom() {\n    return `${this.nome} está cantando`;\n  }\n}\n\nclass Gato extends Animal {\n  constructor(nome) {\n    super(nome);\n  }\n\n  mover() {\n    return `${this.nome} está caminhando`;\n  }\n\n  fazerSom() {\n    return `${this.nome} está miando`;\n  }\n}\n\n// Função que usa polimorfismo\nfunction apresentarAnimal(animal) {\n  console.log(animal.mover());\n  console.log(animal.fazerSom());\n}\n\n// Uso do polimorfismo\nconst animais = [\n  new Peixe('Nemo'),\n  new Passaro('Piu-Piu'),\n  new Gato('Mimi')\n];\n\nanimais.forEach(apresentarAnimal);\n```\n\n## Abstração\n\n### Classes Abstratas\n\n```javascript\n// Classe abstrata para veículos\nclass Veiculo {\n  constructor(marca, modelo, ano) {\n    this.marca = marca;\n    this.modelo = modelo;\n    this.ano = ano;\n    this.ligado = false;\n  }\n\n  // Métodos concretos\n  ligar() {\n    this.ligado = true;\n    return `${this.marca} ${this.modelo} foi ligado`;\n  }\n\n  desligar() {\n    this.ligado = false;\n    return `${this.marca} ${this.modelo} foi desligado`;\n  }\n\n  // Método abstrato (deve ser implementado pelas classes filhas)\n  acelerar() {\n    throw new Error('Método acelerar deve ser implementado');\n  }\n\n  // Método que usa abstração\n  obterInformacoes() {\n    return {\n      marca: this.marca,\n      modelo: this.modelo,\n      ano: this.ano,\n      ligado: this.ligado\n    };\n  }\n}\n\n// Implementação concreta\nclass Carro extends Veiculo {\n  constructor(marca, modelo, ano, combustivel) {\n    super(marca, modelo, ano);\n    this.combustivel = combustivel;\n    this.velocidade = 0;\n  }\n\n  acelerar() {\n    if (!this.ligado) {\n      return 'Ligue o carro primeiro';\n    }\n    this.velocidade += 10;\n    return `${this.marca} ${this.modelo} acelerou para ${this.velocidade} km/h`;\n  }\n\n  frear() {\n    if (this.velocidade > 0) {\n      this.velocidade -= 10;\n      return `${this.marca} ${this.modelo} freou para ${this.velocidade} km/h`;\n    }\n    return 'Carro já está parado';\n  }\n}\n\nclass Moto extends Veiculo {\n  constructor(marca, modelo, ano, cilindradas) {\n    super(marca, modelo, ano);\n    this.cilindradas = cilindradas;\n    this.velocidade = 0;\n  }\n\n  acelerar() {\n    if (!this.ligado) {\n      return 'Ligue a moto primeiro';\n    }\n    this.velocidade += 15;\n    return `${this.marca} ${this.modelo} acelerou para ${this.velocidade} km/h`;\n  }\n\n  empinar() {\n    if (this.velocidade > 30) {\n      return `${this.marca} ${this.modelo} está empinando!`;\n    }\n    return 'Velocidade insuficiente para empinar';\n  }\n}\n\n// Uso da abstração\nconst carro = new Carro('Toyota', 'Corolla', 2023, 'Flex');\nconst moto = new Moto('Honda', 'CB 600', 2023, '600cc');\n\nconsole.log(carro.ligar());\nconsole.log(carro.acelerar());\nconsole.log(moto.ligar());\nconsole.log(moto.acelerar());\n```\n\n## Composição vs Herança\n\n### Composição\n\n```javascript\n// Classes menores e mais específicas\nclass Motor {\n  constructor(tipo, potencia) {\n    this.tipo = tipo;\n    this.potencia = potencia;\n    this.ligado = false;\n  }\n\n  ligar() {\n    this.ligado = true;\n    return `Motor ${this.tipo} ligado`;\n  }\n\n  desligar() {\n    this.ligado = false;\n    return `Motor ${this.tipo} desligado`;\n  }\n}\n\nclass Roda {\n  constructor(tamanho, material) {\n    this.tamanho = tamanho;\n    this.material = material;\n  }\n\n  girar() {\n    return `Roda de ${this.material} girando`;\n  }\n}\n\nclass Volante {\n  constructor(tipo) {\n    this.tipo = tipo;\n  }\n\n  virar(direcao) {\n    return `Virando para ${direcao}`;\n  }\n}\n\n// Classe que usa composição\nclass Automovel {\n  constructor(marca, modelo) {\n    this.marca = marca;\n    this.modelo = modelo;\n    this.motor = new Motor('V8', '300HP');\n    this.rodas = [\n      new Roda(17, 'liga leve'),\n      new Roda(17, 'liga leve'),\n      new Roda(17, 'liga leve'),\n      new Roda(17, 'liga leve')\n    ];\n    this.volante = new Volante('esportivo');\n  }\n\n  ligar() {\n    return this.motor.ligar();\n  }\n\n  desligar() {\n    return this.motor.desligar();\n  }\n\n  acelerar() {\n    if (this.motor.ligado) {\n      return this.rodas.map(roda => roda.girar()).join(', ');\n    }\n    return 'Ligue o motor primeiro';\n  }\n\n  virar(direcao) {\n    return this.volante.virar(direcao);\n  }\n}\n\n// Uso da composição\nconst carro = new Automovel('BMW', 'X5');\nconsole.log(carro.ligar());\nconsole.log(carro.acelerar());\nconsole.log(carro.virar('esquerda'));\n```\n\n## Padrões de Design com OOP\n\n### Singleton\n\n```javascript\nclass DatabaseConnection {\n  constructor() {\n    if (DatabaseConnection.instance) {\n      return DatabaseConnection.instance;\n    }\n\n    this.connectionString = 'localhost:5432/mydb';\n    this.connected = false;\n    DatabaseConnection.instance = this;\n  }\n\n  connect() {\n    if (!this.connected) {\n      this.connected = true;\n      return 'Conectado ao banco de dados';\n    }\n    return 'Já está conectado';\n  }\n\n  disconnect() {\n    if (this.connected) {\n      this.connected = false;\n      return 'Desconectado do banco de dados';\n    }\n    return 'Já está desconectado';\n  }\n\n  getStatus() {\n    return this.connected ? 'Conectado' : 'Desconectado';\n  }\n}\n\n// Uso do Singleton\nconst db1 = new DatabaseConnection();\nconst db2 = new DatabaseConnection();\n\nconsole.log(db1 === db2); // true - mesma instância\nconsole.log(db1.connect());\nconsole.log(db2.getStatus()); // \"Conectado\"\n```\n\n### Factory Pattern\n\n```javascript\nclass AnimalFactory {\n  static criarAnimal(tipo, nome) {\n    switch (tipo.toLowerCase()) {\n      case 'cachorro':\n        return new Cachorro(nome);\n      case 'gato':\n        return new Gato(nome);\n      case 'passaro':\n        return new Passaro(nome);\n      default:\n        throw new Error(`Tipo de animal não suportado: ${tipo}`);\n    }\n  }\n}\n\n// Uso do Factory\nconst animais = [\n  AnimalFactory.criarAnimal('cachorro', 'Rex'),\n  AnimalFactory.criarAnimal('gato', 'Mimi'),\n  AnimalFactory.criarAnimal('passaro', 'Piu-Piu')\n];\n\nanimais.forEach(animal => {\n  console.log(animal.apresentar());\n  console.log(animal.fazerSom());\n});\n```\n\n### Observer Pattern\n\n```javascript\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n\n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(callback => callback(data));\n    }\n  }\n\n  off(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n  }\n}\n\n// Uso do Observer\nclass NotificacaoService extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  enviarNotificacao(mensagem) {\n    console.log(`Enviando: ${mensagem}`);\n    this.emit('notificacao', { mensagem, timestamp: new Date() });\n  }\n}\n\n// Observadores\nconst emailObserver = (data) => {\n  console.log(`Email enviado: ${data.mensagem}`);\n};\n\nconst smsObserver = (data) => {\n  console.log(`SMS enviado: ${data.mensagem}`);\n};\n\n// Uso\nconst notificacao = new NotificacaoService();\nnotificacao.on('notificacao', emailObserver);\nnotificacao.on('notificacao', smsObserver);\n\nnotificacao.enviarNotificacao('Nova mensagem recebida!');\n```\n\n## Boas Práticas\n\n### 1. Princípio da Responsabilidade Única\n\n```javascript\n// ❌ Ruim - classe com múltiplas responsabilidades\nclass Usuario {\n  constructor(nome, email) {\n    this.nome = nome;\n    this.email = email;\n  }\n\n  salvar() {\n    // Lógica de persistência\n  }\n\n  enviarEmail() {\n    // Lógica de envio de email\n  }\n\n  validarEmail() {\n    // Lógica de validação\n  }\n}\n\n// ✅ Bom - classes com responsabilidades específicas\nclass Usuario {\n  constructor(nome, email) {\n    this.nome = nome;\n    this.email = email;\n  }\n}\n\nclass UsuarioRepository {\n  salvar(usuario) {\n    // Lógica de persistência\n  }\n}\n\nclass EmailService {\n  enviarEmail(destinatario, assunto, corpo) {\n    // Lógica de envio de email\n  }\n}\n\nclass ValidadorEmail {\n  validar(email) {\n    // Lógica de validação\n  }\n}\n```\n\n### 2. Princípio Aberto/Fechado\n\n```javascript\n// ✅ Bom - aberto para extensão, fechado para modificação\nclass CalculadoraImposto {\n  calcular(produto) {\n    return produto.preco * 0.1; // 10% de imposto padrão\n  }\n}\n\nclass CalculadoraImpostoAlimenticio extends CalculadoraImposto {\n  calcular(produto) {\n    return produto.preco * 0.05; // 5% para alimentos\n  }\n}\n\nclass CalculadoraImpostoLuxo extends CalculadoraImposto {\n  calcular(produto) {\n    return produto.preco * 0.2; // 20% para produtos de luxo\n  }\n}\n```\n\n### 3. Encapsulamento Adequado\n\n```javascript\n// ✅ Bom - encapsulamento com getters e setters\nclass Produto {\n  constructor(nome, preco) {\n    this._nome = nome;\n    this._preco = preco;\n  }\n\n  get nome() {\n    return this._nome;\n  }\n\n  set nome(novoNome) {\n    if (!novoNome || novoNome.trim() === '') {\n      throw new Error('Nome não pode ser vazio');\n    }\n    this._nome = novoNome;\n  }\n\n  get preco() {\n    return this._preco;\n  }\n\n  set preco(novoPreco) {\n    if (novoPreco < 0) {\n      throw new Error('Preço não pode ser negativo');\n    }\n    this._preco = novoPreco;\n  }\n}\n```\n\n## Conclusão\n\nA Programação Orientada a Objetos em JavaScript oferece uma forma poderosa de organizar e estruturar código complexo. Com o suporte moderno a classes, herança, encapsulamento e outros conceitos OOP, JavaScript se tornou uma linguagem ainda mais versátil.\n\n### Principais Benefícios:\n\n1. **Organização**: Código mais limpo e organizado\n2. **Reutilização**: Componentes podem ser reutilizados facilmente\n3. **Manutenibilidade**: Mais fácil de manter e modificar\n4. **Escalabilidade**: Estrutura que cresce bem com o projeto\n5. **Abstração**: Complexidade oculta através de interfaces claras\n\n### Quando Usar OOP:\n\n- **Projetos grandes** com múltiplos desenvolvedores\n- **Aplicações complexas** com muitas entidades relacionadas\n- **Sistemas que precisam** de alta manutenibilidade\n- **Código que será** reutilizado em diferentes contextos\n\nLembre-se: OOP é uma ferramenta, não uma solução para todos os problemas. Use quando fizer sentido para o seu projeto e sempre priorize a clareza e simplicidade do código.",
    "author": {
        "id": "1",
        "name": "Fábio Ferreira",
        "avatar": "/avatars/fabio.jpg",
        "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
        "social": {
            "github": "https://github.com/FabioSonats",
            "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
            "portfolio": "https://fabiosonats.github.io/my-portifolio/"
        }
    },
    "publishedAt": "2024-01-25T16:45:00Z",
    "updatedAt": "2024-01-25T16:45:00Z",
    "tags": [
        "JavaScript",
        "OOP",
        "Programação Orientada a Objetos",
        "Classes"
    ],
    "category": "javascript",
    "language": "pt",
    "readingTime": 20,
    "featured": true
}