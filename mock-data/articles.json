[
  {
    "id": "1",
    "title": "Introdução ao React Hooks: useState e useEffect",
    "slug": "introducao-react-hooks-usestate-useeffect",
    "excerpt": "Aprenda os conceitos fundamentais dos React Hooks, começando com useState e useEffect, e como eles revolucionaram o desenvolvimento com React.",
    "content": "<h2>O que são React Hooks?</h2><p>Os React Hooks são funções que permitem usar estado e outros recursos do React em componentes funcionais. Eles foram introduzidos no React 16.8 e revolucionaram a forma como escrevemos componentes.</p><h3>useState Hook</h3><p>O useState é o hook mais básico e permite adicionar estado a componentes funcionais:</p><pre><code>import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Você clicou {count} vezes</p>\n      <button onClick={() => setCount(count + 1)}>\n        Clique aqui\n      </button>\n    </div>\n  );\n}</code></pre><h3>useEffect Hook</h3><p>O useEffect permite executar efeitos colaterais em componentes funcionais:</p><pre><code>import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Você clicou ${count} vezes`;\n  });\n\n  return (\n    <div>\n      <p>Você clicou {count} vezes</p>\n      <button onClick={() => setCount(count + 1)}>\n        Clique aqui\n      </button>\n    </div>\n  );\n}</code></pre>",
    "author": {
      "id": "1",
      "name": "P. Sonats",
      "avatar": null,
      "bio": "Desenvolvedor full-stack apaixonado por React e TypeScript",
      "social": {
        "github": "fabiosonats",
        "twitter": "fabiosonats"
      }
    },
    "tags": ["React", "JavaScript", "Hooks", "Frontend"],
    "language": "JavaScript",
    "readingTime": 8,
    "publishedAt": "2024-01-15T10:00:00Z",
    "updatedAt": "2024-01-15T10:00:00Z",
    "featured": true
  },
  {
    "id": "2",
    "title": "TypeScript: Tipos Avançados e Generics",
    "slug": "typescript-tipos-avancados-generics",
    "excerpt": "Explore os tipos mais avançados do TypeScript, incluindo generics, utility types e como criar tipos reutilizáveis e seguros.",
    "content": "<h2>Generics em TypeScript</h2><p>Generics permitem criar componentes reutilizáveis que funcionam com múltiplos tipos. Eles são especialmente úteis para criar funções, interfaces e classes que podem trabalhar com diferentes tipos de dados.</p><h3>Funções Genéricas</h3><pre><code>function identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output = identity<string>('hello');\nlet output2 = identity<number>(42);</code></pre><h3>Interfaces Genéricas</h3><pre><code>interface GenericInterface<T> {\n  value: T;\n  getValue(): T;\n}\n\nclass StringContainer implements GenericInterface<string> {\n  value: string;\n  \n  constructor(value: string) {\n    this.value = value;\n  }\n  \n  getValue(): string {\n    return this.value;\n  }\n}</code></pre>",
    "author": {
      "id": "1",
      "name": "P. Sonats",
      "avatar": null,
      "bio": "Desenvolvedor full-stack apaixonado por React e TypeScript",
      "social": {
        "github": "fabiosonats",
        "twitter": "fabiosonats"
      }
    },
    "tags": ["TypeScript", "JavaScript", "Generics", "Tipos"],
    "language": "TypeScript",
    "readingTime": 12,
    "publishedAt": "2024-01-20T14:30:00Z",
    "updatedAt": "2024-01-20T14:30:00Z",
    "featured": true
  },
  {
    "id": "3",
    "title": "CSS Grid Layout Mastery",
    "slug": "css-grid-layout-mastery",
    "excerpt": "Domine o CSS Grid Layout para criar layouts modernos e responsivos.",
    "content": "<h2>Introdução ao CSS Grid</h2><p>O CSS Grid é uma das ferramentas mais poderosas para criar layouts modernos e responsivos. Ele permite criar layouts bidimensionais com facilidade.</p><h3>Configuração Básica</h3><pre><code>.container {\n  display: grid;\n  grid-template-columns: 1fr 2fr 1fr;\n  grid-template-rows: auto 1fr auto;\n  gap: 20px;\n  height: 100vh;\n}</code></pre><h3>Posicionamento de Itens</h3><pre><code>.item {\n  grid-column: 1 / 3;\n  grid-row: 2 / 4;\n  background: #22d3ee;\n  padding: 20px;\n}</code></pre>",
    "author": {
      "id": "1",
      "name": "Fábio Ferreira",
      "avatar": null,
      "bio": "Desenvolvedor full-stack apaixonado por React e TypeScript",
      "social": {
        "github": "FabioSonats",
        "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
        "portfolio": "https://fabiosonats.github.io/my-portifolio/"
      }
    },
    "tags": ["CSS", "Layout", "Grid"],
    "language": "CSS",
    "readingTime": 10,
    "publishedAt": "2024-01-25T09:15:00Z",
    "updatedAt": "2024-01-25T09:15:00Z",
    "featured": true
  },
  {
    "id": "4",
    "title": "Python: Machine Learning com Scikit-learn",
    "slug": "python-machine-learning-scikit-learn",
    "excerpt": "Introdução prática ao machine learning usando Python e Scikit-learn, desde pré-processamento até avaliação de modelos.",
    "content": "<h2>Introdução ao Scikit-learn</h2><p>O Scikit-learn é uma das bibliotecas mais populares para machine learning em Python. Ela fornece ferramentas simples e eficientes para análise de dados e modelagem preditiva.</p><h3>Instalação e Importação</h3><pre><code>pip install scikit-learn pandas numpy matplotlib\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error</code></pre><h3>Exemplo Prático: Regressão Linear</h3><pre><code># Carregar dados\nfrom sklearn.datasets import load_boston\nboston = load_boston()\nX, y = boston.data, boston.target\n\n# Dividir em treino e teste\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# Treinar modelo\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Fazer previsões\ny_pred = model.predict(X_test)\n\n# Avaliar modelo\nmse = mean_squared_error(y_test, y_pred)\nprint(f'Erro quadrático médio: {mse}')</code></pre>",
    "author": {
      "id": "1",
      "name": "P. Sonats",
      "avatar": null,
      "bio": "Desenvolvedor full-stack apaixonado por React e TypeScript",
      "social": {
        "github": "fabiosonats",
        "twitter": "fabiosonats"
      }
    },
    "tags": [
      "Python",
      "Machine Learning",
      "Scikit-learn",
      "Data Science",
      "AI"
    ],
    "language": "Python",
    "readingTime": 18,
    "publishedAt": "2024-02-01T16:45:00Z",
    "updatedAt": "2024-02-01T16:45:00Z",
    "featured": true
  },
  {
    "id": "5",
    "title": "CSS Grid: Layout Moderno e Responsivo",
    "slug": "css-grid-layout-moderno-responsivo",
    "excerpt": "Domine o CSS Grid para criar layouts complexos e responsivos de forma eficiente, com exemplos práticos e melhores práticas.",
    "content": "<h2>O que é CSS Grid?</h2><p>CSS Grid é um sistema de layout bidimensional que permite criar layouts complexos com linhas e colunas. É especialmente poderoso para criar designs responsivos e alinhamentos precisos.</p><h3>Configuração Básica</h3><pre><code>.container {\n  display: grid;\n  grid-template-columns: 1fr 2fr 1fr;\n  grid-template-rows: auto 1fr auto;\n  gap: 20px;\n  height: 100vh;\n}</code></pre><h3>Layout Responsivo</h3><pre><code>.grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 1rem;\n}\n\n@media (max-width: 768px) {\n  .grid {\n    grid-template-columns: 1fr;\n  }\n}</code></pre><h3>Posicionamento de Itens</h3><pre><code>.item {\n  grid-column: 1 / 3;\n  grid-row: 2 / 4;\n}\n\n.item-2 {\n  grid-area: 1 / 2 / 3 / 4;\n}</code></pre>",
    "author": {
      "id": "1",
      "name": "P. Sonats",
      "avatar": null,
      "bio": "Desenvolvedor full-stack apaixonado por React e TypeScript",
      "social": {
        "github": "fabiosonats",
        "twitter": "fabiosonats"
      }
    },
    "tags": ["CSS", "Grid", "Layout", "Responsivo", "Frontend"],
    "language": "CSS",
    "readingTime": 10,
    "publishedAt": "2024-02-05T11:20:00Z",
    "updatedAt": "2024-02-05T11:20:00Z",
    "featured": false
  },
  {
    "id": "6",
    "title": "Lógica de Programação com Python",
    "slug": "logica-programacao-python",
    "excerpt": "Aprenda os fundamentos da lógica de programação usando Python como linguagem de ensino",
    "content": "# Lógica de Programação com Python\n\nA lógica de programação é a base fundamental para qualquer desenvolvedor. Python, com sua sintaxe clara e legível, é uma excelente linguagem para aprender esses conceitos essenciais.\n\n## O que é Lógica de Programação?\n\nLógica de programação é o conjunto de regras e conceitos que permitem criar algoritmos eficientes e soluções para problemas computacionais. É o pensamento estruturado que transforma uma ideia em código executável.\n\n## Variáveis e Tipos de Dados\n\n### Declaração de Variáveis\nEm Python, as variáveis são criadas automaticamente quando você atribui um valor:\n\n```python\n# Variáveis básicas\nnome = \"João\"\nidade = 25\naltura = 1.75\nativo = True\n\n# Tipos de dados\nprint(type(nome))    # <class 'str'>\nprint(type(idade))   # <class 'int'>\nprint(type(altura))  # <class 'float'>\nprint(type(ativo))   # <class 'bool'>\n```\n\n## Estruturas de Controle\n\n### Condicionais (if, elif, else)\n```python\n# Estrutura básica\nidade = 18\n\nif idade >= 18:\n    print(\"Maior de idade\")\nelif idade >= 16:\n    print(\"Pode votar\")\nelse:\n    print(\"Menor de idade\")\n```\n\n### Loops (for e while)\n```python\n# Loop for - iterando sobre uma lista\nfrutas = [\"maçã\", \"banana\", \"laranja\"]\nfor fruta in frutas:\n    print(f\"Fruta: {fruta}\")\n\n# Loop while\ncontador = 0\nwhile contador < 5:\n    print(f\"Contador: {contador}\")\n    contador += 1\n```\n\n## Funções\n\n```python\n# Função simples\ndef saudacao():\n    print(\"Olá, mundo!\")\n\n# Função com parâmetros\ndef saudacao_personalizada(nome):\n    return f\"Olá, {nome}!\"\n\n# Chamando as funções\nsaudacao()\nmensagem = saudacao_personalizada(\"Ana\")\n```\n\n## Algoritmos Fundamentais\n\n### Busca Linear\n```python\ndef busca_linear(lista, elemento):\n    \"\"\"Busca um elemento em uma lista\"\"\"\n    for i, item in enumerate(lista):\n        if item == elemento:\n            return i\n    return -1\n```\n\n### Fatorial\n```python\ndef fatorial(n):\n    \"\"\"Calcula o fatorial de um número\"\"\"\n    if n < 0:\n        return \"Erro: fatorial não definido para números negativos\"\n    elif n == 0 or n == 1:\n        return 1\n    else:\n        resultado = 1\n        for i in range(2, n + 1):\n            resultado *= i\n        return resultado\n```\n\n## Conclusão\n\nA lógica de programação é a base sólida para se tornar um desenvolvedor competente. Python oferece uma sintaxe clara e intuitiva para aprender esses conceitos fundamentais. Pratique regularmente, resolva problemas e construa projetos para consolidar seu conhecimento.",
    "author": {
      "id": "1",
      "name": "Fábio Ferreira",
      "avatar": "/avatars/fabio.jpg",
      "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
      "social": {
        "github": "https://github.com/FabioSonats",
        "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
        "portfolio": "https://fabiosonats.github.io/my-portifolio/"
      }
    },
    "tags": ["Python", "Lógica de Programação", "Algoritmos"],
    "language": "pt",
    "readingTime": 15,
    "publishedAt": "2024-01-20T14:30:00Z",
    "updatedAt": "2024-01-20T14:30:00Z",
    "featured": true
  },
  {
    "id": "16",
    "title": "Flutter Performance Optimization: Guia Completo",
    "slug": "flutter-performance-optimization",
    "excerpt": "Aprenda as melhores práticas para otimizar performance em aplicações Flutter, desde widgets até animações",
    "content": "# Flutter Performance Optimization: Guia Completo\n\nA performance é crucial para o sucesso de qualquer aplicação móvel. No Flutter, existem várias técnicas e práticas que podem significativamente melhorar a performance da sua aplicação.\n\n## 1. Widgets Otimizados\n\n### const Constructors\n\nUse `const` sempre que possível para evitar reconstruções desnecessárias:\n\n```dart\n// ❌ Ruim - reconstrói a cada build\nWidget build(BuildContext context) {\n  return Container(\n    child: Text('Hello World'),\n  );\n}\n\n// ✅ Bom - const evita reconstruções\nWidget build(BuildContext context) {\n  return const Container(\n    child: Text('Hello World'),\n  );\n}\n```\n\n### RepaintBoundary\n\nUse `RepaintBoundary` para isolar widgets que mudam frequentemente:\n\n```dart\nclass AnimatedWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: Container(\n        width: 100,\n        height: 100,\n        color: Colors.blue,\n        child: AnimatedBuilder(\n          animation: _animation,\n          builder: (context, child) {\n            return Transform.rotate(\n              angle: _animation.value * 2 * math.pi,\n              child: child,\n            );\n          },\n          child: const Icon(Icons.star),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 2. Listas Otimizadas\n\n### ListView.builder\n\nUse `ListView.builder` para listas grandes:\n\n```dart\n// ✅ Bom - renderiza apenas itens visíveis\nListView.builder(\n  itemCount: items.length,\n  itemBuilder: (context, index) {\n    return ListTile(\n      title: Text(items[index].title),\n      subtitle: Text(items[index].subtitle),\n    );\n  },\n)\n\n// ❌ Ruim - renderiza todos os itens\nColumn(\n  children: items.map((item) => ListTile(\n    title: Text(item.title),\n  )).toList(),\n)\n```\n\n### AutomaticKeepAliveClientMixin\n\nMantenha o estado de widgets em listas:\n\n```dart\nclass KeepAliveWidget extends StatefulWidget {\n  @override\n  _KeepAliveWidgetState createState() => _KeepAliveWidgetState();\n}\n\nclass _KeepAliveWidgetState extends State<KeepAliveWidget> \n    with AutomaticKeepAliveClientMixin {\n  \n  @override\n  bool get wantKeepAlive => true;\n  \n  @override\n  Widget build(BuildContext context) {\n    super.build(context); // Importante!\n    return YourWidget();\n  }\n}\n```\n\n## 3. Imagens Otimizadas\n\n### Cached Network Image\n\n```dart\ndependencies:\n  cached_network_image: ^3.2.3\n\n// Uso\nCachedNetworkImage(\n  imageUrl: 'https://example.com/image.jpg',\n  placeholder: (context, url) => CircularProgressIndicator(),\n  errorWidget: (context, url, error) => Icon(Icons.error),\n  memCacheWidth: 300, // Reduz uso de memória\n  memCacheHeight: 200,\n)\n```\n\n### Image.asset vs Image.network\n\n```dart\n// ✅ Para imagens locais - mais rápido\nImage.asset('assets/images/logo.png')\n\n// ✅ Para imagens da web - com cache\nCachedNetworkImage(\n  imageUrl: 'https://example.com/image.jpg',\n  cacheManager: DefaultCacheManager(),\n)\n```\n\n## 4. Animações Performáticas\n\n### AnimationController\n\n```dart\nclass OptimizedAnimation extends StatefulWidget {\n  @override\n  _OptimizedAnimationState createState() => _OptimizedAnimationState();\n}\n\nclass _OptimizedAnimationState extends State<OptimizedAnimation> \n    with SingleTickerProviderStateMixin {\n  \n  late AnimationController _controller;\n  late Animation<double> _animation;\n  \n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: Duration(seconds: 2),\n      vsync: this,\n    );\n    _animation = Tween<double>(begin: 0, end: 1).animate(_controller);\n  }\n  \n  @override\n  void dispose() {\n    _controller.dispose(); // Importante!\n    super.dispose();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) {\n        return Transform.scale(\n          scale: _animation.value,\n          child: child,\n        );\n      },\n      child: const Icon(Icons.star, size: 50),\n    );\n  }\n}\n```\n\n### TweenAnimationBuilder\n\n```dart\n// ✅ Para animações simples\nTweenAnimationBuilder<double>(\n  tween: Tween(begin: 0, end: 1),\n  duration: Duration(seconds: 1),\n  builder: (context, value, child) {\n    return Opacity(\n      opacity: value,\n      child: child,\n    );\n  },\n  child: Text('Hello World'),\n)\n```\n\n## 5. Gerenciamento de Estado\n\n### Provider vs setState\n\n```dart\n// ✅ Provider - mais eficiente\nclass CounterProvider extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n  \n  void increment() {\n    _count++;\n    notifyListeners(); // Notifica apenas listeners\n  }\n}\n\n// Uso\nConsumer<CounterProvider>(\n  builder: (context, counter, child) {\n    return Text('Count: ${counter.count}');\n  },\n)\n```\n\n### Bloc Pattern\n\n```dart\n// events\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\n\n// states\nabstract class CounterState {}\nclass CounterInitial extends CounterState {}\nclass CounterLoaded extends CounterState {\n  final int count;\n  CounterLoaded(this.count);\n}\n\n// bloc\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterInitial()) {\n    on<IncrementEvent>((event, emit) {\n      if (state is CounterLoaded) {\n        final currentState = state as CounterLoaded;\n        emit(CounterLoaded(currentState.count + 1));\n      } else {\n        emit(CounterLoaded(1));\n      }\n    });\n  }\n}\n```\n\n## 6. Debugging Performance\n\n### Flutter Inspector\n\n```dart\n// Adicione ao main.dart para debug\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      showPerformanceOverlay: true, // Mostra overlay de performance\n      home: MyHomePage(),\n    );\n  }\n}\n```\n\n### Performance Monitoring\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass PerformanceMonitor {\n  static void measureBuildTime(String widgetName, VoidCallback builder) {\n    final stopwatch = Stopwatch()..start();\n    builder();\n    stopwatch.stop();\n    \n    if (kDebugMode) {\n      print('$widgetName build time: ${stopwatch.elapsedMicroseconds}μs');\n    }\n  }\n}\n\n// Uso\nWidget build(BuildContext context) {\n  return PerformanceMonitor.measureBuildTime('MyWidget', () {\n    return Container(\n      child: Text('Hello World'),\n    );\n  });\n}\n```\n\n## 7. Otimizações de Memória\n\n### WeakReference\n\n```dart\nclass DataManager {\n  static final Map<String, WeakReference<Object>> _cache = {};\n  \n  static T? getCachedData<T>(String key) {\n    final ref = _cache[key];\n    if (ref != null && ref.target != null) {\n      return ref.target as T?;\n    }\n    _cache.remove(key);\n    return null;\n  }\n  \n  static void cacheData(String key, Object data) {\n    _cache[key] = WeakReference(data);\n  }\n}\n```\n\n### Disposal Pattern\n\n```dart\nclass ResourceManager {\n  final List<StreamSubscription> _subscriptions = [];\n  final List<Timer> _timers = [];\n  \n  void addSubscription(StreamSubscription subscription) {\n    _subscriptions.add(subscription);\n  }\n  \n  void addTimer(Timer timer) {\n    _timers.add(timer);\n  }\n  \n  void dispose() {\n    for (final subscription in _subscriptions) {\n      subscription.cancel();\n    }\n    for (final timer in _timers) {\n      timer.cancel();\n    }\n    _subscriptions.clear();\n    _timers.clear();\n  }\n}\n```\n\n## 8. Build Optimization\n\n### shouldRebuild\n\n```dart\nclass OptimizedWidget extends StatelessWidget {\n  final String title;\n  final int count;\n  \n  const OptimizedWidget({\n    Key? key,\n    required this.title,\n    required this.count,\n  }) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return Text('$title: $count');\n  }\n  \n  @override\n  bool shouldRebuild(OptimizedWidget oldWidget) {\n    return title != oldWidget.title || count != oldWidget.count;\n  }\n}\n```\n\n## 9. Network Optimization\n\n### HTTP Caching\n\n```dart\nimport 'package:http/http.dart' as http;\nimport 'package:shared_preferences/shared_preferences.dart';\n\nclass CachedHttpClient {\n  static const String _cacheKey = 'http_cache';\n  \n  static Future<String> get(String url) async {\n    final prefs = await SharedPreferences.getInstance();\n    final cacheKey = '${_cacheKey}_$url';\n    \n    // Verifica cache\n    final cachedData = prefs.getString(cacheKey);\n    if (cachedData != null) {\n      return cachedData;\n    }\n    \n    // Faz requisição\n    final response = await http.get(Uri.parse(url));\n    final data = response.body;\n    \n    // Salva no cache\n    await prefs.setString(cacheKey, data);\n    \n    return data;\n  }\n}\n```\n\n## 10. Conclusão\n\nA otimização de performance no Flutter envolve:\n\n- **Widgets**: Use `const`, `RepaintBoundary`\n- **Listas**: `ListView.builder`, `AutomaticKeepAliveClientMixin`\n- **Imagens**: Cache, compressão\n- **Animações**: `AnimationController`, `TweenAnimationBuilder`\n- **Estado**: Provider, Bloc\n- **Debug**: Flutter Inspector, Performance Monitor\n- **Memória**: WeakReference, Disposal Pattern\n- **Network**: HTTP Caching\n\nLembre-se: **meça antes de otimizar**. Use as ferramentas de debug do Flutter para identificar gargalos reais antes de aplicar otimizações.\n\n## Recursos Adicionais\n\n- [Flutter Performance Best Practices](https://docs.flutter.dev/perf/best-practices)\n- [Flutter Inspector](https://docs.flutter.dev/development/tools/flutter-inspector)\n- [Performance Profiling](https://docs.flutter.dev/perf/ui-performance)\n\n---\n\n**Dica**: Sempre teste a performance em dispositivos reais, não apenas no emulador!",
    "author": {
      "id": "1",
      "name": "Fábio Ferreira",
      "avatar": "/avatars/fabio.jpg",
      "bio": "Desenvolvedor Full-Stack e criador de conteúdo técnico",
      "social": {
        "github": "https://github.com/FabioSonats",
        "linkedin": "https://www.linkedin.com/in/ferreira-f%C3%A1bio-98b4304a/",
        "portfolio": "https://fabiosonats.github.io/my-portifolio/"
      }
    },
    "tags": [
      "Flutter",
      "Performance",
      "Optimization",
      "Mobile Development",
      "Dart"
    ],
    "language": "pt",
    "readingTime": 15,
    "publishedAt": "2025-01-26T14:30:00Z",
    "updatedAt": "2025-01-26T14:30:00Z",
    "featured": true
  }
]
